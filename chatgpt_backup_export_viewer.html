<!DOCTYPE html>
<!--
Project: ChatGPT Backup Export Viewer
Version: v0.9.6 ‚Äî Full-Text Search
Date: 2025-10-25
Author: Bob van Zeeland (Kronosnxs)
License: MIT License ¬© 2025 Kronosnxs
License URL: https://github.com/Kronosnxs/ChatGPT-Backup-Export-Viewer/blob/main/LICENSE
-->
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ChatGPT Backup Export Viewer ‚Äî v0.9.6</title>
    <style>
      /* ========================================
         CSS CUSTOM PROPERTIES (CSS VARIABLES)
         ======================================== */
      /* Dark theme color palette for the application */
      :root {
        --bg: #0f1320;          /* Primary background color */
        --panel: #151a2b;       /* Sidebar panel background */
        --muted: #8aa1c1;       /* Muted text color for secondary information */
        --text: #e6eefc;        /* Primary text color */
        --accent: #6aa9ff;      /* Primary accent color for interactive elements */
        --accent-2: #7cf4e7;    /* Secondary accent color for highlights */
        --danger: #ff6a8a;      /* Danger/warning color */
        --border: #22304d;      /* Border color for dividers and containers */
        --chip: #1b2340;        /* Background color for chip/badge elements */
        --code-bg: #0a1024;     /* Background color for code blocks */
        --mark: #264d8b;        /* Background color for highlighted/marked text */
      }

      /* ========================================
         GLOBAL RESETS & BASE STYLES
         ======================================== */
      /* Apply border-box sizing to all elements for easier layout calculations */
      * {
        box-sizing: border-box;
      }

      /* Ensure html and body take full viewport height */
      html,
      body {
        height: 100%;
      }

      /* Body styling with system font stack and gradient background */
      body {
        margin: 0;
        font: 14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Helvetica,
          Arial, "Apple Color Emoji", "Segoe UI Emoji";
        color: var(--text);
        /* Vertical gradient background for visual depth */
        background: linear-gradient(
          180deg,
          #0b0e18 0%,
          #0f1320 60%,
          #0b0e18 100%
        );
      }

      /* ========================================
         MAIN LAYOUT STRUCTURE
         ======================================== */
      /* Two-column grid layout: sidebar (360px) + main content (flexible) */
      .app {
        display: grid;
        grid-template-columns: 360px 1fr;
        height: 100vh;
      }

      /* Sidebar panel: sticky positioning, vertical flex layout */
      aside {
        background: var(--panel);
        border-right: 1px solid var(--border);
        display: flex;
        flex-direction: column;
        position: sticky;
        top: 0;
        min-height: 100vh;
      }

      /* ========================================
         HEADER SECTION (SIDEBAR TOP)
         ======================================== */
      /* App title and version display */
      header {
        padding: 16px 16px 8px;
        border-bottom: 1px solid var(--border);
      }

      /* Main heading in header */
      header h1 {
        margin: 0 0 4px 0;
        font-size: 16px;
      }

      /* Subtitle text (version information) */
      header .sub {
        margin: 0;
        color: var(--muted);
        font-size: 12px;
      }

      /* ========================================
         CONTROLS SECTION (FILE INPUTS & FILTERS)
         ======================================== */
      /* Container for all file input controls, filters, and sort options */
      .controls {
        padding: 12px 16px;
        display: grid;
        gap: 8px;
        border-bottom: 1px solid var(--border);
      }

      /* Horizontal row layout for grouping controls */
      .row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      /* Button styling with gradient background */
      .btn {
        background: linear-gradient(180deg, #1e2642, #16203a);
        color: var(--text);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px 12px;
        cursor: pointer;
        font-weight: 600;
      }

      /* Button hover state for interactivity feedback */
      .btn:hover {
        border-color: #2f4475;
      }

      /* Hide native file input elements (replaced by styled labels) */
      input[type="file"] {
        display: none;
      }

      /* Special styling for folder input (completely hidden but functional) */
      input[type="file"].folder {
        display: block;
        width: 0;
        height: 0;
        opacity: 0;
        position: absolute;
        pointer-events: none;
      }

      /* Status chip/badge for displaying load state */
      .chip {
        border: 1px solid var(--border);
        background: var(--chip);
        border-radius: 999px;
        padding: 6px 10px;
        font-size: 12px;
        color: var(--muted);
      }

      /* Status color modifiers */
      .ok {
        color: #9bf2e1;  /* Success state (green-cyan) */
      }
      .warn {
        color: #ffd68a;  /* Warning state (yellow) */
      }
      .danger {
        color: var(--danger);  /* Error state (red) */
      }

      /* Search and filter input field styling */
      .search {
        width: 100%;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: #0f152b;
        color: var(--text);
      }

      /* ========================================
         CONVERSATION LIST (SIDEBAR)
         ======================================== */
      /* Scrollable container for conversation items */
      .list {
        overflow: auto;
        padding: 8px 8px 24px;
        flex: 1;  /* Takes remaining space in sidebar flex container */
      }

      /* Individual conversation item card */
      .item {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px 12px;
        margin: 8px;
        background: linear-gradient(180deg, #121a33, #0f1630);
        cursor: pointer;
      }

      /* Conversation item hover state */
      .item:hover {
        border-color: #2f4475;
      }

      /* Conversation title styling */
      .title {
        font-weight: 600;
      }

      /* Conversation metadata (date, ID) styling */
      .meta {
        font-size: 12px;
        color: var(--muted);
      }

      /* ========================================
         MAIN CONTENT AREA
         ======================================== */
      /* Primary content panel (right side of screen) */
      main {
        padding: 20px 24px;
        overflow: auto;
      }

      /* Small badge/label styling for metadata display */
      .pill {
        font-size: 11px;
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid var(--border);
        color: var(--muted);
      }

      /* Keyboard shortcut display styling (monospace font) */
      .kbd {
        background: #0a1024;
        border: 1px solid var(--border);
        padding: 2px 6px;
        border-radius: 6px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        font-size: 12px;
        color: var(--muted);
      }

      /* Flex row with space between items (for headers) */
      .row-space {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
      }

      /* ========================================
         TAB NAVIGATION
         ======================================== */
      /* Container for tab buttons */
      .tabs {
        display: flex;
        gap: 8px;
        margin: 10px 0 18px 0;
      }

      /* Individual tab button styling */
      .tab {
        padding: 8px 12px;
        border: 1px solid var(--border);
        border-radius: 999px;
        cursor: pointer;
        background: #0f152b;
      }

      /* Active tab indicator (outline) */
      .tab.active {
        outline: 2px solid #2f4475;
      }

      /* Tab view containers (hidden by default) */
      .view {
        display: none;
      }

      /* Show active tab view */
      .view.active {
        display: block;
      }

      /* ========================================
         MESSAGE DISPLAY
         ======================================== */
      /* Individual message card styling */
      .msg {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px 12px;
        background: #0f162d;
        margin: 10px 0;
      }

      /* Message author/role label */
      .msg .who {
        font-weight: 600;
      }

      /* Message timestamp display */
      .msg .when {
        font-size: 12px;
        color: var(--muted);
      }

      /* Code block container with monospace font */
      pre.code {
        background: var(--code-bg);
        border: 1px solid var(--border);
        padding: 12px;
        border-radius: 10px;
        overflow: auto;
        white-space: pre-wrap;
        word-break: break-word;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
      }

      /* Copy button for code blocks */
      .copy {
        cursor: pointer;
        font-size: 12px;
      }

      /* Empty state message styling (dashed border) */
      .empty {
        color: var(--muted);
        border: 1px dashed var(--border);
        padding: 16px;
        border-radius: 12px;
        margin-top: 12px;
      }

      /* ========================================
         TABLE STYLING (ATTACHMENTS)
         ======================================== */
      /* Table container for attachment display */
      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 8px;
      }

      /* Table cell styling */
      th,
      td {
        padding: 8px 10px;
        border-bottom: 1px solid var(--border);
        text-align: left;
        vertical-align: top;
      }

      /* Table header styling */
      th {
        color: var(--muted);
      }

      /* Thumbnail image styling (for attachment previews) */
      .thumb {
        max-width: 200px;
        max-height: 120px;
        display: block;
        border: 1px solid var(--border);
        border-radius: 8px;
      }

      /* ========================================
         GRID LAYOUT (ATTACHMENT CARDS)
         ======================================== */
      /* Responsive grid for file cards */
      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
        gap: 12px;
      }

      /* Individual file card in grid */
      .card {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px;
        background: #0f162d;
      }

      /* Filename display in card */
      .fname {
        font-weight: 600;
      }

      /* ========================================
         SEARCH HIGHLIGHTING
         ======================================== */
      /* Highlighted search term styling */
      mark {
        background: var(--mark);
        color: #dbe7ff;
        padding: 0 2px;
        border-radius: 3px;
      }

      /* Search controls container */
      .sr-controls {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
        margin: 8px 0 4px;
      }

      /* Search result count display */
      .sr-count {
        font-size: 12px;
        color: var(--muted);
      }

      /* Individual search result card */
      .result {
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 10px;
        margin: 8px 0;
        background: #101a34;
        cursor: pointer;
      }

      /* Search result title */
      .result h4 {
        margin: 0 0 6px 0;
      }

      /* Muted text utility class */
      .muted {
        color: var(--muted);
        font-size: 12px;
      }
    </style>
  </head>
  <body>
    <!-- ========================================
         MAIN APPLICATION CONTAINER
         Two-column layout: sidebar + main content
         ======================================== -->
    <div class="app">
      <!-- ========================================
           LEFT SIDEBAR - FILE INPUTS & CONVERSATION LIST
           ======================================== -->
      <aside>
        <!-- Header: Application title and version -->
        <header>
          <h1>ChatGPT Backup Export Viewer</h1>
          <p class="sub">v0.9.6 ‚Äî Full-Text Search</p>
        </header>

        <!-- Controls: File upload inputs, filters, and sort options -->
        <div class="controls">
          <!-- JSON file upload -->
          <div class="row">
            <label class="btn" for="fileJSON">üì• conversation.json</label>
            <input id="fileJSON" type="file" accept=".json,application/json" />
            <span id="jsonChip" class="chip"
              >JSON: <span class="warn">not loaded</span></span
            >
          </div>

          <!-- HTML file upload -->
          <div class="row">
            <label class="btn" for="fileHTML">üìÑ chat.html</label>
            <input id="fileHTML" type="file" accept=".html,text/html" />
            <span id="htmlChip" class="chip"
              >HTML: <span class="warn">not loaded</span></span
            >
          </div>

          <!-- Folder/directory upload for attachments -->
          <div class="row">
            <label class="btn" for="folderBtn"
              >üìÅ Import attachments folder</label
            >
            <input
              id="folderBtn"
              class="folder"
              type="file"
              webkitdirectory
              directory
              multiple
            />
            <span id="attChip" class="chip"
              >Files: <span class="warn">0</span></span
            >
          </div>

          <!-- Filter input: Search/filter conversations by title or ID -->
          <div class="row">
            <input
              id="filterSidebar"
              class="search"
              placeholder="Filter sidebar by title/ID‚Ä¶"
            />
          </div>

          <!-- Sort dropdown: Sort conversations by date or title -->
          <div class="row">
            <select id="sort" class="search" title="Sort by">
              <option value="date_desc">Sort: Date ‚Üì</option>
              <option value="date_asc">Sort: Date ‚Üë</option>
              <option value="title_asc">Sort: Title A‚ÜíZ</option>
              <option value="title_desc">Sort: Title Z‚ÜíA</option>
            </select>
          </div>

          <!-- Keyboard shortcuts display -->
          <div class="row">
            <span class="chip"
              >Shortcuts: <span class="kbd">Ctrl/Cmd+O</span> JSON,
              <span class="kbd">Ctrl/Cmd+Shift+O</span> HTML</span
            >
          </div>
        </div>

        <!-- Conversation list container (populated dynamically by JavaScript) -->
        <div id="list" class="list" aria-live="polite"></div>
      </aside>

      <!-- ========================================
           MAIN CONTENT AREA - MESSAGE VIEWER & TABS
           ======================================== -->
      <main>
        <!-- Header with conversation title and info -->
        <div class="row-space">
          <h2 id="viewTitle">Viewer</h2>
          <div id="viewInfo" class="pill">No conversation selected</div>
        </div>

        <!-- Tab navigation for different views -->
        <div class="tabs">
          <div id="tabMsg" class="tab active">Messages</div>
          <div id="tabAtt" class="tab">Attachments</div>
          <div id="tabExp" class="tab">Export</div>
          <div id="tabSearch" class="tab">Search Results</div>
        </div>

        <!-- ========================================
             TAB CONTENT SECTIONS
             ======================================== -->

        <!-- Messages View: Displays conversation messages -->
        <section id="viewMessages" class="view active">
          <div id="messages"></div>
          <div id="placeholder" class="empty">
            Load your <strong>conversation.json</strong> and
            <strong>chat.html</strong>, then pick a conversation from the
            sidebar.<br />
            All content is escaped and shown as text. No code is executed.
          </div>
        </section>

        <!-- Attachments View: Displays referenced files and local imports -->
        <section id="viewAttachments" class="view">
          <div class="hint">
            Merges references parsed from chat.html/JSON with local files you
            imported. Offline previews via Blob URLs.
          </div>
          <div id="attTableWrap" class="empty">No conversation selected.</div>
          <h3 style="margin-top: 18px">Unattached files</h3>
          <div id="unattached" class="empty">No local files imported.</div>
        </section>

        <!-- Export View: Export options for current conversation -->
        <section id="viewExport" class="view">
          <div class="hint">
            Export the current conversation as JSON or Markdown, and generate a
            Virtual Restore manifest.
          </div>
          <div class="row" style="margin-top: 10px">
            <button id="btnJSON" class="btn">Export JSON</button>
            <button id="btnMD" class="btn">Export Markdown</button>
            <button id="btnManifest" class="btn">
              Generate Restore Manifest
            </button>
          </div>
          <div id="expInfo" class="empty" style="margin-top: 12px">
            No conversation selected.
          </div>
        </section>

        <!-- Search View: Full-text search across all conversations -->
        <section id="viewSearch" class="view">
          <div class="sr-controls">
            <input
              id="searchInput"
              class="search"
              placeholder="Search messages (e.g., index.html, 'render pipeline')‚Ä¶"
              style="flex: 1"
            />
            <label class="pill" style="padding: 4px 8px"
              ><input
                id="chkAttach"
                type="checkbox"
                style="vertical-align: middle; margin-right: 6px"
              />Include attachments</label
            >
            <button id="btnSearch" class="btn">Search</button>
            <button id="btnClear" class="btn">Clear</button>
            <span id="srCount" class="sr-count"></span>
          </div>
          <!-- Search results populated dynamically -->
          <div id="results"></div>
        </section>
      </main>
    </div>

    <!-- ========================================
         JAVASCRIPT - APPLICATION LOGIC
         ======================================== -->
    <script>
      /**
       * Main application IIFE (Immediately Invoked Function Expression)
       * Encapsulates all application logic to avoid global scope pollution
       */
      (function () {
        "use strict";

        /**
         * DOM query selector shortcuts
         * @param {string} sel - CSS selector
         * @param {Element|Document} root - Root element to search from
         * @returns {Element|null} First matching element
         */
        const $ = (sel, root = document) => root.querySelector(sel);

        /**
         * DOM query selector for multiple elements
         * @param {string} sel - CSS selector
         * @param {Element|Document} root - Root element to search from
         * @returns {Array<Element>} Array of matching elements
         */
        const $$ = (sel, root = document) =>
          Array.from(root.querySelectorAll(sel));

        /**
         * Cache of DOM element references for performance
         * All UI elements are stored here to avoid repeated DOM queries
         */
        const els = {
          fileJSON: $("#fileJSON"),
          fileHTML: $("#fileHTML"),
          folderBtn: $("#folderBtn"),
          list: $("#list"),
          filterSidebar: $("#filterSidebar"),
          sort: $("#sort"),
          jsonChip: $("#jsonChip"),
          htmlChip: $("#htmlChip"),
          attChip: $("#attChip"),
          messages: $("#messages"),
          viewTitle: $("#viewTitle"),
          viewInfo: $("#viewInfo"),
          placeholder: $("#placeholder"),
          tabMsg: $("#tabMsg"),
          tabAtt: $("#tabAtt"),
          tabExp: $("#tabExp"),
          tabSearch: $("#tabSearch"),
          viewMessages: $("#viewMessages"),
          viewAttachments: $("#viewAttachments"),
          viewExport: $("#viewExport"),
          viewSearch: $("#viewSearch"),
          attTableWrap: $("#attTableWrap"),
          unattached: $("#unattached"),
          btnJSON: $("#btnJSON"),
          btnMD: $("#btnMD"),
          btnManifest: $("#btnManifest"),
          expInfo: $("#expInfo"),
          searchInput: $("#searchInput"),
          chkAttach: $("#chkAttach"),
          btnSearch: $("#btnSearch"),
          btnClear: $("#btnClear"),
          results: $("#results"),
          srCount: $("#srCount"),
        };

        /* ========================================
           APPLICATION STATE
           ======================================== */
        /** @type {Array<Object>} Array of all loaded conversations */
        let conversations = [];

        /** @type {Object<string, Array>} Messages indexed by conversation ID from JSON */
        let messagesById = {};

        /** @type {Object<string, Array>} Messages indexed by conversation ID from HTML */
        let htmlMessagesById = {};

        /** @type {Object<string, Array>} Attachments indexed by conversation ID */
        let attachmentsById = {};

        /** @type {Object<string, Object>} Local files indexed by basename */
        let localByBase = {};

        /** @type {Object<string, Array<string>>} Local file basenames mapped to conversation IDs */
        let localMapByConv = {};

        /** @type {Array<Object>} Filtered conversations based on search/sort */
        let filtered = [];

        /** @type {Object|null} Currently selected/displayed conversation */
        let currentConv = null;

        /** @type {Array<string>} Search terms for highlighting */
        let highlightTerms = [];

        /* ========================================
           UTILITY FUNCTIONS
           ======================================== */

        /**
         * Updates a status chip element with text and status color
         * @param {HTMLElement} el - The chip element to update
         * @param {boolean} ok - Whether the status is successful (true) or error (false)
         * @param {string} [text] - Optional text to display (defaults to "loaded" or "not loaded")
         */
        function setChip(el, ok, text) {
          el.innerHTML = escapeHTML(text || (ok ? "loaded" : "not loaded"));
          el.className = "chip " + (ok ? "ok" : "danger");
        }

        /**
         * Extracts the filename from a file path
         * @param {string} p - File path (can use forward or back slashes)
         * @returns {string} Filename only, without directory path
         */
        function basename(p) {
          if (!p) return "";
          const parts = String(p).split(/[\\/]/).filter(Boolean);
          return parts.pop() || "";
        }

        /**
         * Escapes HTML special characters to prevent XSS attacks
         * @param {string} s - String to escape
         * @returns {string} HTML-safe string
         */
        function escapeHTML(s) {
          return String(s).replace(
            /[&<>"']/g,
            (ch) =>
              ({
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#39;",
              }[ch])
          );
        }

        /**
         * Escapes double quotes for HTML attribute values
         * @param {string} s - String to escape
         * @returns {string} Attribute-safe string
         */
        function escapeAttr(s) {
          return String(s).replace(/"/g, "&quot;");
        }

        /**
         * Sanitizes a string to be used as a safe filename
         * @param {string} s - String to sanitize
         * @returns {string} Safe filename (max 80 chars, alphanumeric and hyphens/underscores)
         */
        function safeName(s) {
          return String(s || "conversation")
            .replace(/[^\w\-]+/g, "_")
            .slice(0, 80);
        }

        /**
         * Converts various timestamp formats to Unix timestamp (seconds)
         * Handles milliseconds, strings, and various numeric formats
         * @param {number|string|null|undefined} v - Timestamp value to convert
         * @returns {number} Unix timestamp in seconds, or 0 if invalid
         */
        function toTs(v) {
          if (v === null || v === undefined) return 0;
          if (typeof v === "number") {
            if (v > 1e12) return Math.floor(v / 1000); // Milliseconds to seconds
            if (v > 1e9) return Math.floor(v); // Already in seconds
            if (v > 1e8) return Math.floor(v); // Ambiguous range
            return 0;
          }
          if (typeof v === "string") {
            const d = new Date(v);
            if (!Number.isNaN(d.getTime()))
              return Math.floor(d.getTime() / 1000);
            const n = Number(v);
            if (Number.isFinite(n)) return toTs(n);
          }
          return 0;
        }

        /**
         * Formats Unix timestamp as human-readable date string
         * @param {number} sec - Unix timestamp in seconds
         * @returns {string} Formatted date string (YYYY-MM-DD HH:mm) or empty string
         */
        function formatDate(sec) {
          try {
            if (!sec) return "";
            const d = new Date(sec * 1000);
            const y = d.getFullYear(),
              m = String(d.getMonth() + 1).padStart(2, "0"),
              dd = String(d.getDate()).padStart(2, "0"),
              hh = String(d.getHours()).padStart(2, "0"),
              mi = String(d.getMinutes()).padStart(2, "0");
            return `${y}-${m}-${dd} ${hh}:${mi}`;
          } catch {
            return "";
          }
        }

        /**
         * Guesses MIME type based on file extension
         * @param {string} href - File URL or path
         * @param {string} name - Filename
         * @returns {string} MIME type string
         */
        function guessType(href, name) {
          const s = (href || name || "").toLowerCase();
          if (/\.(png|jpg|jpeg|gif|webp|bmp|svg)(\?|$)/.test(s))
            return "image/png";
          if (/\.(mp4|mov|webm|mkv)(\?|$)/.test(s)) return "video/mp4";
          if (/\.(mp3|wav|ogg|m4a)(\?|$)/.test(s)) return "audio/mpeg";
          if (/\.(pdf)(\?|$)/.test(s)) return "application/pdf";
          if (/\.(zip|rar|7z|tar|gz)(\?|$)/.test(s)) return "application/zip";
          if (/\.(html|htm)(\?|$)/.test(s)) return "text/html";
          if (/\.(js|ts|json|csv|txt|md|xml|yml|yaml)(\?|$)/.test(s))
            return "text/plain";
          return "application/octet-stream";
        }

        /**
         * Normalizes file reference strings by removing schemes, queries, and ensuring extensions
         * Handles ChatGPT's file_XXXXX format and various URL schemes
         * @param {string} ref - File reference string to normalize
         * @returns {string} Normalized lowercase filename
         */
        function normalizeFileRef(ref) {
          if (!ref) return "";
          let base = String(ref).trim();
          base = base.replace(/^sediment:\/\//i, ""); // remove scheme
          base = base.replace(/^asset:\/\//i, "");
          base = base.split(/[?#]/)[0]; // strip query or fragment
          // match both full and partial IDs
          const core = base.match(/file_[A-Za-z0-9]+/i);
          base = core ? core[0] : base;
          if (!/\.[a-z0-9]{2,5}$/i.test(base)) base += ".png"; // ensure extension
          return basename(base).toLowerCase();
        }

        /**
         * Extracts conversation ID from various object property formats
         * @param {Object} o - Conversation object
         * @returns {string} Conversation ID or empty string
         */
        function pickId(o) {
          return String(
            o?.id ||
              o?.conversation_id ||
              o?.uuid ||
              o?.thread_id ||
              o?.threadId ||
              o?.slug ||
              ""
          ).trim();
        }

        /**
         * Extracts conversation title from various object property formats
         * @param {Object} o - Conversation object
         * @returns {string} Conversation title or "(untitled)"
         */
        function pickTitle(o) {
          let t = o?.title || o?.name || o?.topic || o?.subject || "";
          if (!t && typeof o?.mapping?.title === "string") t = o.mapping.title;
          return String(t || "(untitled)").trim();
        }

        /**
         * Extracts timestamp from various object property formats
         * @param {Object} o - Conversation object
         * @returns {number} Unix timestamp in seconds, or 0 if not found
         */
        function pickDate(o) {
          const cand = [
            o?.create_time,
            o?.created_at,
            o?.created,
            o?.createdAt,
            o?.timestamp,
            o?.time,
            o?.date,
          ];
          for (const c of cand) {
            const v = toTs(c);
            if (v) return v;
          }
          return 0;
        }

        /* ========================================
           TAB NAVIGATION
           ======================================== */

        /**
         * Switches active tab view in the main content area
         * @param {string} key - Tab key: "msg", "att", "exp", or "search"
         */
        function activateTab(key) {
          [els.tabMsg, els.tabAtt, els.tabExp, els.tabSearch].forEach((x) =>
            x.classList.remove("active")
          );
          [
            els.viewMessages,
            els.viewAttachments,
            els.viewExport,
            els.viewSearch,
          ].forEach((x) => x.classList.remove("active"));
          if (key === "msg") {
            els.tabMsg.classList.add("active");
            els.viewMessages.classList.add("active");
          }
          if (key === "att") {
            els.tabAtt.classList.add("active");
            els.viewAttachments.classList.add("active");
          }
          if (key === "exp") {
            els.tabExp.classList.add("active");
            els.viewExport.classList.add("active");
          }
          if (key === "search") {
            els.tabSearch.classList.add("active");
            els.viewSearch.classList.add("active");
          }
        }

        /* ========================================
           EVENT LISTENERS
           ======================================== */
        $("#tabMsg").addEventListener("click", () => activateTab("msg"));
        $("#tabAtt").addEventListener("click", () => activateTab("att"));
        $("#tabExp").addEventListener("click", () => activateTab("exp"));
        $("#tabSearch").addEventListener("click", () => activateTab("search"));

        window.addEventListener("keydown", (e) => {
          const key = e.key.toLowerCase();
          if ((e.ctrlKey || e.metaKey) && key === "f") {
            e.preventDefault();
            activateTab("search");
            els.searchInput.focus();
          }
        });

        // Inputs
        els.fileJSON.addEventListener("change", (e) => {
          const f = e.target.files?.[0];
          if (f) loadJSONFile(f);
          e.target.value = "";
        });
        els.fileHTML.addEventListener("change", (e) => {
          const f = e.target.files?.[0];
          if (f) loadHTMLFile(f);
          e.target.value = "";
        });
        els.folderBtn.addEventListener("change", (e) => {
          const files = Array.from(e.target.files || []);
          if (files.length) importLocalFiles(files);
          e.target.value = "";
        });
        els.filterSidebar.addEventListener("input", applyFilters);
        els.sort.addEventListener("change", applyFilters);
        els.btnSearch.addEventListener("click", runSearch);
        els.btnClear.addEventListener("click", () => {
          els.searchInput.value = "";
          els.results.innerHTML = "";
          els.srCount.textContent = "";
          highlightTerms = [];
        });

        /* ========================================
           DRAG & DROP SUPPORT
           ======================================== */

        // Prevent default drag behavior
        document.addEventListener("dragover", (e) => {
          e.preventDefault();
        });

        // Handle dropped files
        document.addEventListener("drop", (e) => {
          e.preventDefault();
          const files = [...(e.dataTransfer?.files || [])];
          if (files.length) {
            const json = files.find((x) => /\.json$/i.test(x.name));
            const html = files.find((x) => /\.html?$/i.test(x.name));
            if (json && files.length === 1) loadJSONFile(json);
            if (html && files.length === 1) loadHTMLFile(html);
            if (files.length > 1 || (!json && !html)) importLocalFiles(files);
          }
        });

        /* ========================================
           FILE PARSING HELPERS
           ======================================== */

        /**
         * Recursively searches for file references (file_XXXXX format) in nested objects
         * @param {*} node - Object, array, string, or primitive to search
         * @param {Set<string>} [acc=new Set()] - Accumulator set for found file references
         * @param {number} [depth=0] - Current recursion depth (max 6)
         * @returns {Set<string>} Set of file reference strings found
         */
        function deepFindFileRefs(node, acc = new Set(), depth = 0) {
          if (depth > 6) return acc; // Prevent infinite recursion
          if (node === null || node === undefined) return acc;
          if (typeof node === "string") {
            const m = node.match(/file_[A-Za-z0-9._-]+/g);
            if (m) for (const x of m) acc.add(x);
            return acc;
          }
          if (Array.isArray(node)) {
            for (const v of node) deepFindFileRefs(v, acc, depth + 1);
            return acc;
          }
          if (typeof node === "object") {
            for (const k in node) {
              if (!Object.prototype.hasOwnProperty.call(node, k)) continue;
              deepFindFileRefs(node[k], acc, depth + 1);
            }
          }
          return acc;
        }

        /**
         * Traverses up the DOM tree to find a conversation ID attribute
         * @param {HTMLElement} node - Starting DOM element
         * @returns {string} Conversation ID or empty string
         */
        function findConversationId(node) {
          let el = node;
          while (el) {
            const cid = el.getAttribute?.("data-conversation-id");
            if (cid) return cid;
            el = el.parentElement;
          }
          return "";
        }

        /**
         * Searches for a preceding script tag with JSON containing a conversation ID
         * @param {HTMLElement} el - Starting DOM element
         * @returns {Object|null} Object with cid property, or null if not found
         */
        function findPrevScriptWithId(el) {
          let cur = el;
          for (let i = 0; i < 30 && cur; i++) {
            cur = cur.previousElementSibling || cur.parentElement;
            if (
              cur &&
              cur.tagName === "SCRIPT" &&
              cur.getAttribute("type") === "application/json"
            ) {
              try {
                const j = JSON.parse(cur.textContent || "{}");
                const cid = String(j.id || j.conversation_id || "").trim();
                if (cid) return { cid };
              } catch {}
            }
          }
          return null;
        }

        /* ========================================
           FILE LOADING FUNCTIONS
           ======================================== */

        /**
         * Loads and parses a conversation.json file
         * Updates the global conversations and messagesById objects
         * @param {File} file - The JSON file to load
         */
        function loadJSONFile(file) {
          const reader = new FileReader();
          reader.onload = () => {
            try {
              const data = JSON.parse(String(reader.result));
              const normalized = normalizeConversations(data);
              conversations = normalized.items;
              messagesById = normalized.messagesById;
              filtered = conversations.slice();
              applyFilters();
              setChip(els.jsonChip, true, `JSON: loaded (${file.name})`);
            } catch (err) {
              console.error(err);
              setChip(els.jsonChip, false, "JSON: failed to parse");
            }
          };
          reader.readAsText(file);
        }

        /**
         * Loads and parses a chat.html file exported from ChatGPT
         * Extracts messages and attachment references
         * @param {File} file - The HTML file to load
         */
        function loadHTMLFile(file) {
          const reader = new FileReader();
          reader.onload = () => {
            try {
              const htmlRaw = String(reader.result);
              const parsed = parseChatHTML(htmlRaw);
              htmlMessagesById = parsed.messages;
              for (const k in parsed.attachments) {
                (attachmentsById[k] = attachmentsById[k] || []).push(
                  ...parsed.attachments[k]
                );
              }
              setChip(els.htmlChip, true, `HTML: loaded (${file.name})`);
              rebuildLocalMap();
            } catch (err) {
              console.error(err);
              setChip(els.htmlChip, false, "HTML: failed to parse");
            }
          };
          reader.readAsText(file);
        }

        /**
         * Parses HTML content to extract messages and file attachments
         * Looks for embedded JSON scripts and HTML elements with file references
         * @param {string} text - Raw HTML content
         * @returns {Object} Object with messages and attachments properties
         */
        function parseChatHTML(text) {
          const out = { messages: {}, attachments: {} };
          try {
            const parser = new DOMParser();
            const doc = parser.parseFromString(text, "text/html");
            const scripts = document.querySelectorAll(
              'script[type="application/json"]',
              doc
            );
            const list = scripts.length
              ? scripts
              : doc.querySelectorAll('script[type="application/json"]');
            for (const s of list) {
              try {
                const json = JSON.parse(s.textContent || "{}");
                if (json.mapping && typeof json.mapping === "object") {
                  const msgs = [];
                  for (const k in json.mapping) {
                    const node = json.mapping[k];
                    const m = node?.message || node;
                    const sh = shapeMappingMessage(m);
                    if (sh) msgs.push(sh);
                  }
                  const cid = String(
                    json.id || json.conversation_id || ""
                  ).trim();
                  if (cid && msgs.length) {
                    msgs.sort(
                      (a, b) => (a.create_time || 0) - (b.create_time || 0)
                    );
                    out.messages[cid] = (out.messages[cid] || []).concat(msgs);
                  }
                }
                const arrays = [];
                if (Array.isArray(json.items)) arrays.push(json.items);
                if (Array.isArray(json.threads)) arrays.push(json.threads);
                if (Array.isArray(json.conversations))
                  arrays.push(json.conversations);
                for (const arr of arrays) {
                  for (const obj of arr) {
                    const cid = pickId(obj);
                    if (!cid) continue;
                    const inline = extractInlineMessages(obj);
                    if (inline.length) {
                      inline.sort(
                        (a, b) => (a.create_time || 0) - (b.create_time || 0)
                      );
                      out.messages[cid] = (out.messages[cid] || []).concat(
                        inline
                      );
                    }
                    const files = deepFindFileRefs(obj);
                    for (const fname of files) {
                      const att = {
                        cid,
                        href: fname,
                        filename: fname,
                        type: guessType(fname, fname),
                        source: "json",
                      };
                      (out.attachments[cid] = out.attachments[cid] || []).push(
                        att
                      );
                    }
                  }
                }
                const topCid = String(
                  json.id || json.conversation_id || ""
                ).trim();
                if (topCid) {
                  const filesTop = deepFindFileRefs(json);
                  for (const fname of filesTop) {
                    const att = {
                      cid: topCid,
                      href: fname,
                      filename: fname,
                      type: guessType(fname, fname),
                      source: "json",
                    };
                    (out.attachments[topCid] =
                      out.attachments[topCid] || []).push(att);
                  }
                }
              } catch {}
            }
            const linkNodes = doc.querySelectorAll("a[href], img[src]");
            for (const n of linkNodes) {
              const href =
                n.getAttribute("href") || n.getAttribute("src") || "";
              if (!href) continue;
              const m = href.match(/(^|[\\/])file_[^?#"'<>\\s]+/i);
              if (!m) continue;
              const fname = m[0].split(/[\\/]/).pop();
              let cid = findConversationId(n);
              if (!cid) {
                const prev = findPrevScriptWithId(n);
                cid = prev?.cid || "";
              }
              const att = {
                cid: cid || "__unknown__",
                href: fname,
                filename: fname,
                type: guessType(href, fname),
                context: (n.textContent || "").trim().slice(0, 200),
                source: "html",
              };
              (out.attachments[att.cid] = out.attachments[att.cid] || []).push(
                att
              );
            }
          } catch (e) {
            console.warn("HTML parse error", e);
          }
          return out;
        }

        /**
         * Normalizes conversation data from various JSON export formats
         * Handles different array structures (conversations, items, threads, etc.)
         * @param {Object|Array} data - Raw JSON data from conversation.json
         * @returns {Object} Object with items array and messagesById object
         */
        function normalizeConversations(data) {
          const candidates = [];
          if (Array.isArray(data)) candidates.push(data);
          if (Array.isArray(data.conversations))
            candidates.push(data.conversations);
          if (Array.isArray(data.items)) candidates.push(data.items);
          if (Array.isArray(data.threads)) candidates.push(data.threads);
          if (candidates.length === 0) {
            for (const k in data) {
              if (
                Array.isArray(data[k]) &&
                data[k].length &&
                typeof data[k][0] === "object"
              ) {
                candidates.push(data[k]);
              }
            }
          }
          const arr = candidates[0] || [];
          const items = [];
          const msgs = {};
          for (const obj of arr) {
            const id = pickId(obj);
            const title = pickTitle(obj);
            const date = pickDate(obj);
            if (!id || !title) continue;
            items.push({ id, title, date });
            const inline = extractInlineMessages(obj);
            if (inline.length) msgs[id] = inline;
          }
          return { items, messagesById: msgs };
        }

        /**
         * Extracts messages from various nested object structures
         * Handles messages arrays, mapping objects, and thread structures
         * @param {Object} obj - Conversation object to extract messages from
         * @returns {Array<Object>} Array of normalized message objects
         */
        function extractInlineMessages(obj) {
          const out = [];
          if (Array.isArray(obj.messages)) {
            for (const m of obj.messages) {
              const msg = shapeMessage(m);
              if (msg) out.push(msg);
            }
          }
          if (obj.mapping && typeof obj.mapping === "object") {
            for (const k in obj.mapping) {
              const node = obj.mapping[k];
              const m = node?.message || node;
              const msg = shapeMappingMessage(m);
              if (msg) out.push(msg);
            }
          }
          if (obj.thread && Array.isArray(obj.thread.messages)) {
            for (const m of obj.thread.messages) {
              const msg = shapeMessage(m);
              if (msg) out.push(msg);
            }
          }
          out.sort((a, b) => (a.create_time || 0) - (b.create_time || 0));
          return out;
        }

        /**
         * Recursively extracts text content from nested message structures
         * Handles strings, arrays, and objects with various text properties
         * @param {*} m - Message content (can be string, array, object, or nested structure)
         * @returns {string} Extracted text content
         */
        function extractTextContent(m) {
          if (!m) return "";
          if (typeof m === "string") return m;
          if (Array.isArray(m)) return m.map(extractTextContent).join("\n");
          if (typeof m === "object") {
            if (Array.isArray(m.parts))
              return m.parts.map(extractTextContent).join("\n");
            if (m.text) return extractTextContent(m.text);
            if (m.value) return extractTextContent(m.value);
            if (m.message) return extractTextContent(m.message);
            if (m.data) return extractTextContent(m.data);
            // fallback: flatten primitive values
            return Object.values(m)
              .filter((v) => typeof v !== "object")
              .join(" ");
          }
          return "";
        }

        /**
         * Normalizes a message object to standard format
         * @param {Object} m - Raw message object
         * @returns {Object|null} Normalized message with id, author, role, create_time, content
         */
        function shapeMessage(m) {
          try {
            const id = String(m.id || m.message_id || m.uuid || "").trim();
            const role = m.role || m.author?.role || m.sender || "unknown";
            const author = m.author?.name || role;
            const create_time = toTs(
              m.create_time || m.created_at || m.timestamp || m.time || 0
            );
            const content = extractTextContent(m.content);
            return { id, author, role, create_time, content };
          } catch {
            return null;
          }
        }

        function shapeMappingMessage(m) {
          try {
            const id = String(m.id || m.message_id || "").trim();
            const role = m.author?.role || "unknown";
            const author = m.author?.name || role;
            const create_time = toTs(m.create_time || 0);
            const content = extractTextContent(m.content);
            return { id, author, role, create_time, content };
          } catch {
            return null;
          }
        }

        /**
         * Normalizes message from mapping structure (chat.html format)
         * @param {Object} m - Raw message from mapping object
         * @returns {Object|null} Normalized message or null if invalid
         */
        function shapeMappingMessage(m) {
          try {
            const id = String(m.id || m.message_id || "").trim();
            const role = m.author?.role || "unknown";
            const author = m.author?.name || role;
            const create_time = toTs(m.create_time || 0);
            const content = extractTextContent(m.content);
            return { id, author, role, create_time, content };
          } catch {
            return null;
          }
        }

        /* ========================================
           SIDEBAR - CONVERSATION LIST & FILTERING
           ======================================== */

        /**
         * Applies search filter and sort order to conversation list
         * Updates the filtered array and re-renders the sidebar
         */
        function applyFilters() {
          const q = els.filterSidebar.value.trim().toLowerCase();
          const mode = els.sort.value;
          let arr = conversations.slice();
          if (q) {
            arr = arr.filter(
              (c) =>
                c.title.toLowerCase().includes(q) ||
                c.id.toLowerCase().includes(q)
            );
          }
          arr.sort((a, b) => {
            if (mode === "date_desc") return (b.date || 0) - (a.date || 0);
            if (mode === "date_asc") return (a.date || 0) - (b.date || 0);
            if (mode === "title_asc") return a.title.localeCompare(b.title);
            if (mode === "title_desc") return b.title.localeCompare(a.title);
            return 0;
          });
          filtered = arr;
          renderList();
        }

        /**
         * Renders the filtered conversation list in the sidebar
         * Creates clickable cards for each conversation
         */
        function renderList() {
          if (filtered.length === 0) {
            els.list.innerHTML =
              '<div class="empty" role="status">No conversations found. Import your <code>conversation.json</code>.</div>';
            return;
          }
          const frag = document.createDocumentFragment();
          for (const c of filtered) {
            const div = document.createElement("div");
            div.className = "item";
            div.innerHTML = `<div class="title">${escapeHTML(c.title)}</div>
          <div class="meta"><span class="pill">${
            c.date ? escapeHTML(formatDate(c.date)) : "No date"
          }</span>&nbsp;‚Ä¢&nbsp;<span class="pill">${escapeHTML(
              shortId(c.id)
            )}</span></div>`;
            div.addEventListener("click", () => showConversation(c));
            frag.appendChild(div);
          }
          els.list.innerHTML = "";
          els.list.appendChild(frag);
        }

        /**
         * Truncates long conversation IDs for display
         * @param {string} id - Full conversation ID
         * @returns {string} Truncated ID with ellipsis if too long
         */
        function shortId(id) {
          return id.length > 24 ? id.slice(0, 12) + "‚Ä¶" + id.slice(-8) : id;
        }

        /* ========================================
           CONVERSATION DISPLAY
           ======================================== */

        /**
         * Displays a selected conversation in the main content area
         * Merges messages from JSON and HTML sources, renders messages and attachments
         * @param {Object} conv - Conversation object to display
         */
        function showConversation(conv) {
          currentConv = conv;
          els.viewTitle.textContent = conv.title;
          els.expInfo.textContent = `Ready to export ‚Äú${conv.title}‚Äù`;
          const sources = [];
          const jsonMsgs = messagesById[conv.id] || [];
          if (jsonMsgs.length) sources.push({ name: "JSON", msgs: jsonMsgs });
          const htmlMsgs = htmlMessagesById[conv.id] || [];
          if (htmlMsgs.length) sources.push({ name: "HTML", msgs: htmlMsgs });
          els.placeholder.style.display = "none";
          const map = new Map();
          for (const src of sources) {
            for (const m of src.msgs) {
              if (!map.has(m.id)) map.set(m.id, m);
            }
          }
          const list = Array.from(map.values()).sort(
            (a, b) => (a.create_time || 0) - (b.create_time || 0)
          );
          els.viewInfo.textContent =
            sources.map((s) => `${s.name}:${s.msgs.length}`).join(" ¬∑ ") ||
            "No messages found";
          // Merge inline file references from message content into attachments
          const refsInline = [];
          for (const m of list) {
            const matches =
              String(m.content || "").match(/file_[A-Za-z0-9._-]+/g) || [];
            for (const r of matches) {
              const norm = normalizeFileRef(r);
              if (!attachmentsById[conv.id]) attachmentsById[conv.id] = [];
              const already = attachmentsById[conv.id].some(
                (a) => normalizeFileRef(a.filename || a.href) === norm
              );
              if (!already) {
                const matchKey = Object.keys(localByBase).find((k) =>
                  normalizeFileRef(k).startsWith(norm.replace(/\.png$/, ""))
                );
                const type = matchKey
                  ? localByBase[matchKey].type
                  : guessType(norm, norm);
                attachmentsById[conv.id].push({
                  cid: conv.id,
                  href: norm,
                  filename: norm,
                  type,
                  source: "inline",
                });
              }
            }
          }

          renderMessages(list);
          renderAttachments(conv.id);
          if (highlightTerms.length) {
            highlightInView(highlightTerms);
          }
        }

        /**
         * Renders message list in the main content area
         * Creates message cards with author, timestamp, content, and inline file previews
         * @param {Array<Object>} list - Array of normalized message objects
         */
        function renderMessages(list) {
          const frag = document.createDocumentFragment();
          if (!list.length) {
            const empty = document.createElement("div");
            empty.className = "empty";
            empty.textContent = "No messages to display.";
            frag.appendChild(empty);
          } else {
            for (const m of list) {
              const card = document.createElement("div");
              card.className = "msg";
              card.id = `msg_${m.id}`;
              const top = document.createElement("div");
              top.className = "row-space";
              const who = document.createElement("div");
              who.className = "who";
              who.textContent = `${m.author || m.role || "unknown"}`;
              const when = document.createElement("div");
              when.className = "when";
              when.textContent = m.create_time ? formatDate(m.create_time) : "";
              top.appendChild(who);
              top.appendChild(when);
              const pre = document.createElement("pre");
              pre.className = "code";
              let content = String(m.content || "");

              // detect inline file references like file_00000...
              const refs = content.match(/file_[A-Za-z0-9._-]+/g) || [];
              if (refs.length) {
                let html = escapeHTML(content);
                for (const r of refs) {
                  const base = normalizeFileRef(r);
                  const matchKey = Object.keys(localByBase).find((k) =>
                    normalizeFileRef(k).startsWith(base.replace(/\.png$/, ""))
                  );

                  const match = matchKey ? localByBase[matchKey] : null;

                  if (match) {
                    const isImg = /^image\//.test(match.type);
                    const thumb = isImg
                      ? `<img src="${match.url}" alt="${escapeAttr(
                          base
                        )}" class="thumb" style="max-width:140px;display:block;margin:6px 0;">`
                      : `<a href="${match.url}" download="${escapeAttr(
                          base
                        )}">${escapeHTML(base)}</a>`;
                    const safeURL = escapeAttr(match.url);
                    html = html.replace(
                      new RegExp(escapeRegExp(r), "g"),
                      `<a href="${safeURL}" target="_blank">${escapeHTML(
                        base
                      )}</a><br>${thumb}`
                    );
                  } else {
                    // fallback link (not loaded locally)
                    html = html.replace(
                      new RegExp(escapeRegExp(r), "g"),
                      `<span class="muted">${escapeHTML(r)} (not found)</span>`
                    );
                  }
                }
                pre.innerHTML = html;
              } else {
                pre.textContent = content;
              }

              const copy = document.createElement("div");
              copy.className = "copy pill";
              copy.textContent = "Copy";
              copy.addEventListener("click", () => {
                navigator.clipboard
                  .writeText(pre.textContent || "")
                  .catch(() => {});
                copy.textContent = "Copied";
                setTimeout(() => (copy.textContent = "Copy"), 1200);
              });
              const line2 = document.createElement("div");
              line2.className = "row-space";
              line2.appendChild(document.createElement("div"));
              line2.appendChild(copy);
              card.appendChild(top);
              card.appendChild(pre);
              card.appendChild(line2);
              frag.appendChild(card);
            }
          }
          els.messages.innerHTML = "";
          els.messages.appendChild(frag);
        }

        /**
         * Renders attachment tables and local file grids for a conversation
         * Displays referenced files from HTML/JSON and locally imported files
         * @param {string} cid - Conversation ID
         */
        function renderAttachments(cid) {
          const links = (attachmentsById[cid] || []).slice();
          const localBases = localMapByConv[cid] || [];
          const localFiles = localBases
            .map((b) => localByBase[b])
            .filter(Boolean);

          // üîπ Inline + thumbnail rendering
          let linkHTML = "";
          if (links.length) {
            const rows = links
              .map((a) => {
                const base = basename(a.filename || a.href || "").toLowerCase();
                const matchKey = Object.keys(localByBase).find(
                  (k) => normalizeFileRef(k) === normalizeFileRef(base)
                );
                const local = matchKey ? localByBase[matchKey] : null;
                const thumb =
                  local && /^image\//.test(local.type)
                    ? `<img src="${local.url}" alt="${escapeAttr(
                        base
                      )}" class="thumb" style="max-width:120px;max-height:90px;border-radius:8px;">`
                    : "";

                return `<tr>
          <td style="width:140px;">${thumb || "‚Äî"}</td>
          <td>${escapeHTML(base)}</td>
          <td>${escapeHTML(a.type || "")}</td>
          <td>${escapeHTML(a.href)}</td>
          <td>${escapeHTML(a.context || "")}</td>
        </tr>`;
              })
              .join("");

            linkHTML = `<h3>References (${links.length})</h3>
    <table>
      <thead>
        <tr>
          <th>Preview</th>
          <th>Filename</th>
          <th>Type</th>
          <th>Ref</th>
          <th>Context</th>
        </tr>
      </thead>
      <tbody>${rows}</tbody>
    </table>`;
          } else linkHTML = `<div class="empty">No references found.</div>`;

          // üîπ Local matches (unchanged)
          let localHTML = "";
          if (localFiles.length) {
            const cards = localFiles
              .map((lf) => {
                const img = /^image\//.test(lf.type)
                  ? `<img class="thumb" src="${lf.url}" alt="${escapeAttr(
                      lf.name
                    )}" style="max-width:120px;max-height:90px;border-radius:8px;">`
                  : "";
                const down = `<a href="${lf.url}" download="${escapeAttr(
                  lf.name
                )}">Download</a>`;
                return `<div class="card"><div class="fname">${escapeHTML(
                  lf.name
                )}</div>${img}<div class="hint">${escapeHTML(
                  lf.type || "file"
                )} ‚Ä¢ ${lf.size} bytes ‚Ä¢ ${escapeHTML(
                  lf.path
                )}</div>${down}</div>`;
              })
              .join("");
            localHTML = `<h3>Local files matched (${localFiles.length})</h3><div class="grid">${cards}</div>`;
          } else
            localHTML = `<div class="empty">No local files matched this conversation.</div>`;

          els.attTableWrap.className = "";
          els.attTableWrap.innerHTML = linkHTML + localHTML;
        }

        /**
         * Imports local attachment files and creates Blob URLs for offline preview
         * Filters for ChatGPT export files (file_XXXXX) and known file extensions
         * @param {Array<File>} files - Array of File objects to import
         */
        function importLocalFiles(files) {
          for (const f of files) {
            const base = basename(f.name);
            const rel = f.webkitRelativePath || f.name;
            const inUser = /(^|[\\/])user-[^\\/]+[\\/]/i.test(rel);
            const isExport = /^file_/i.test(base) || inUser;
            const isKnownExt =
              /\.(png|jpe?g|webp|gif|svg|pdf|zip|txt|md|json|html?|csv|xml|js|ts)$/i.test(
                base
              );
            if (!isExport && !isKnownExt) continue;
            if (localByBase[base]) continue;
            const url = URL.createObjectURL(f);
            localByBase[base] = {
              name: base,
              path: rel,
              url,
              type: f.type || guessType(base, base),
              size: f.size || 0,
            };
          }
          setChip(
            els.attChip,
            true,
            `Files: ${Object.keys(localByBase).length}`
          );
          rebuildLocalMap();
        }

        /**
         * Rebuilds the mapping between local files and conversations
         * Matches imported files to conversation attachments by filename
         */
        function rebuildLocalMap() {
          localMapByConv = {};
          for (const cid in attachmentsById) {
            for (const a of attachmentsById[cid] || []) {
              const key = (
                basename(a.filename || "") || basename(a.href || "")
              ).toLowerCase();
              if (!key) continue;
              const matchKey = Object.keys(localByBase).find(
                (k) => k.toLowerCase() === key
              );
              if (matchKey) {
                (localMapByConv[cid] = localMapByConv[cid] || []).push(
                  matchKey
                );
              }
            }
          }
          updateUnattached();
        }

        /**
         * Updates the display of unattached local files (files not linked to any conversation)
         * Renders a grid of file cards for orphaned files
         */
        function updateUnattached() {
          const attached = new Set(Object.values(localMapByConv).flat());
          const unatt = Object.keys(localByBase).filter(
            (b) => !attached.has(b)
          );
          const el = els.unattached;
          if (!unatt.length) {
            el.className = "empty";
            el.textContent = "No unattached local files.";
            return;
          }
          const grid = document.createElement("div");
          grid.className = "grid";
          for (const base of unatt) {
            const lf = localByBase[base];
            const card = document.createElement("div");
            card.className = "card";
            const name = document.createElement("div");
            name.className = "fname";
            name.textContent = lf.name;
            card.appendChild(name);
            if (/^image\//.test(lf.type)) {
              const img = document.createElement("img");
              img.className = "thumb";
              img.src = lf.url;
              img.alt = lf.name;
              card.appendChild(img);
            }
            const a = document.createElement("a");
            a.href = lf.url;
            a.download = lf.name;
            a.textContent = "Download";
            card.appendChild(a);
            grid.appendChild(card);
          }
          el.className = "";
          el.innerHTML = "";
          el.appendChild(grid);
        }

        /* ========================================
           SEARCH FUNCTIONALITY
           ======================================== */

        /**
         * Executes full-text search across all loaded conversations
         * Searches messages and optionally attachments for all search terms
         * Groups results by conversation and renders them
         */
        function runSearch() {
          const q = els.searchInput.value.trim();
          activateTab("search");
          if (!q) {
            els.results.innerHTML =
              '<div class="empty">Enter a word or phrase to search.</div>';
            els.srCount.textContent = "";
            return;
          }
          const terms = q.toLowerCase().split(/\s+/).filter(Boolean);
          highlightTerms = terms.slice();
          const hits = [];
          for (const c of conversations) {
            const cid = c.id;
            const title = c.title;
            // merge messages
            const js = messagesById[cid] || [];
            const hm = htmlMessagesById[cid] || [];
            const map = new Map();
            for (const m of js) {
              if (!map.has(m.id)) map.set(m.id, m);
            }
            for (const m of hm) {
              if (!map.has(m.id)) map.set(m.id, m);
            }
            for (const m of map.values()) {
              const text = String(m.content || "");
              const low = text.toLowerCase();
              let ok = true;
              for (const t of terms) {
                if (!low.includes(t)) {
                  ok = false;
                  break;
                }
              }
              if (ok) {
                hits.push({
                  cid,
                  mid: m.id,
                  title,
                  author: m.author || m.role || "unknown",
                  when: m.create_time || 0,
                  snippet: makeSnippet(text, terms),
                });
              }
            }
            if (els.chkAttach.checked) {
              const atts = attachmentsById[cid] || [];
              for (const a of atts) {
                const txt =
                  (a.filename || a.href || "") + " " + (a.context || "");
                const low = txt.toLowerCase();
                let ok = true;
                for (const t of terms) {
                  if (!low.includes(t)) {
                    ok = false;
                    break;
                  }
                }
                if (ok) {
                  hits.push({
                    cid,
                    mid: `att_${a.filename || a.href}`,
                    title,
                    author: "(attachment)",
                    when: 0,
                    snippet: makeSnippet(txt, terms),
                  });
                }
              }
            }
          }
          // group and render
          const byCid = new Map();
          for (const h of hits) {
            if (!byCid.has(h.cid)) byCid.set(h.cid, []);
            byCid.get(h.cid).push(h);
          }
          const entries = Array.from(byCid.entries()).sort(
            (a, b) => b[1].length - a[1].length
          );
          els.srCount.textContent = `${hits.length} matches in ${entries.length} conversations`;
          if (!entries.length) {
            els.results.innerHTML =
              '<div class="empty">No matches found.</div>';
            return;
          }
          const frag = document.createDocumentFragment();
          for (const [cid, arr] of entries) {
            const div = document.createElement("div");
            div.className = "result";
            const title =
              conversations.find((c) => c.id === cid)?.title || "(unknown)";
            div.innerHTML = `<h4>${escapeHTML(title)}</h4><div class="muted">${
              arr.length
            } match(es)</div>`;
            const ul = document.createElement("div");
            for (const h of arr.slice(0, 3)) {
              const p = document.createElement("div");
              p.className = "muted";
              p.innerHTML = h.snippet;
              ul.appendChild(p);
            }
            div.appendChild(ul);
            div.addEventListener("click", () => {
              const first = arr[0];
              const conv = conversations.find((c) => c.id === cid);
              if (conv) {
                showConversation(conv);
                setTimeout(() => {
                  const target = document.getElementById("msg_" + first.mid);
                  if (target) {
                    target.scrollIntoView({
                      behavior: "smooth",
                      block: "center",
                    });
                    pulse(target);
                  }
                  highlightInView(highlightTerms);
                }, 80);
                activateTab("msg");
              }
            });
            frag.appendChild(div);
          }
          els.results.innerHTML = "";
          els.results.appendChild(frag);
        }

        /**
         * Adds a temporary visual pulse effect to a DOM element
         * @param {HTMLElement} node - Element to pulse
         */
        function pulse(node) {
          node.style.outline = "2px solid var(--accent-2)";
          setTimeout(() => (node.style.outline = ""), 800);
        }

        /**
         * Creates a text snippet with highlighted search terms
         * Extracts text around the first matching term
         * @param {string} text - Full text to create snippet from
         * @param {Array<string>} terms - Search terms to highlight
         * @returns {string} HTML snippet with highlighted terms
         */
        function makeSnippet(text, terms) {
          const lower = text.toLowerCase();
          let idx = -1;
          for (const t of terms) {
            const i = lower.indexOf(t);
            if (i >= 0) {
              idx = i;
              break;
            }
          }
          if (idx < 0) idx = 0;
          const start = Math.max(0, idx - 40),
            end = Math.min(text.length, idx + 80);
          const chunk = text.slice(start, end);
          return highlight(chunk, terms);
        }

        /**
         * Highlights search terms within the displayed messages
         * Uses TreeWalker to only highlight text nodes, preserving existing HTML
         * @param {Array<string>} terms - Search terms to highlight
         */
        function highlightInView(terms) {
          const pres = document.querySelectorAll("#messages pre.code");
          for (const pre of pres) {
            // Only highlight plain text segments, not existing HTML (like <img>)
            const walker = document.createTreeWalker(pre, NodeFilter.SHOW_TEXT);
            const textNodes = [];
            while (walker.nextNode()) textNodes.push(walker.currentNode);
            for (const node of textNodes) {
              const frag = document.createElement("span");
              frag.innerHTML = highlight(
                escapeHTML(node.textContent),
                terms,
                true
              );
              node.replaceWith(...frag.childNodes);
            }
          }
        }

        /**
         * Wraps search terms in <mark> tags for highlighting
         * @param {string} s - Text to highlight
         * @param {Array<string>} terms - Terms to highlight
         * @param {boolean} [alreadyEscaped=false] - Whether text is already HTML-escaped
         * @returns {string} HTML with highlighted terms
         */
        function highlight(s, terms, alreadyEscaped) {
          let text = s;
          if (!alreadyEscaped) text = escapeHTML(text);
          for (const t of terms) {
            const re = new RegExp("(" + escapeRegExp(t) + ")", "ig");
            text = text.replace(re, "<mark>$1</mark>");
          }
          return text;
        }

        /**
         * Escapes special regex characters in a string
         * @param {string} s - String to escape
         * @returns {string} Regex-safe string
         */
        function escapeRegExp(s) {
          return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        }

        /* ========================================
           EXPORT FUNCTIONALITY
           ======================================== */

        /**
         * Builds a complete JSON export object for a conversation
         * Merges messages from JSON and HTML sources, includes attachments and local files
         * @param {Object} conv - Conversation object to export
         * @returns {Object} Export object with all conversation data
         */
        function buildExportJSON(conv) {
          const msgs = (messagesById[conv.id] || []).concat(
            htmlMessagesById[conv.id] || []
          );
          const seen = new Set();
          const uniq = [];
          for (const m of msgs) {
            if (m && !seen.has(m.id)) {
              seen.add(m.id);
              uniq.push(m);
            }
          }
          const linkAtt = attachmentsById[conv.id] || [];
          const localBases = localMapByConv[conv.id] || [];
          const localFiles = localBases
            .map((b) => localByBase[b])
            .filter(Boolean);
          return {
            id: conv.id,
            title: conv.title,
            date: conv.date,
            messages: uniq.sort(
              (a, b) => (a.create_time || 0) - (b.create_time || 0)
            ),
            attachments: linkAtt,
            localFiles: localFiles.map((f) => ({
              name: f.name,
              path: f.path,
              type: f.type,
              size: f.size,
            })),
          };
        }

        /**
         * Builds a Markdown export of a conversation
         * Includes headers, messages, attachments, and local file listings
         * @param {Object} conv - Conversation object to export
         * @returns {string} Markdown-formatted conversation
         */
        function buildExportMarkdown(conv) {
          const data = buildExportJSON(conv);
          const lines = [];
          lines.push(`# ${escapeMD(data.title)}\n`);
          lines.push(`**Conversation ID:** ${escapeMD(data.id)}  `);
          lines.push(`**Date:** ${data.date ? formatDate(data.date) : ""}\n`);
          lines.push(`## Messages\n`);
          for (const m of data.messages) {
            const who = m.author || m.role || "unknown";
            const when = m.create_time ? formatDate(m.create_time) : "";
            lines.push(`### ${escapeMD(who)} ‚Äî ${when}`);
            lines.push("");
            lines.push("```");
            lines.push(String(m.content || ""));
            lines.push("```");
            lines.push("");
          }
          lines.push("## Attachments (refs from chat.html / JSON)");
          if (!data.attachments.length) lines.push("_No references detected._");
          else
            for (const a of data.attachments) {
              lines.push(
                `- ${escapeMD(a.filename || "(unknown)")} ‚Äî ${escapeMD(
                  a.type || "file"
                )} ‚Äî ${a.href}`
              );
            }
          lines.push("\n## Local files (imported)");
          if (!data.localFiles.length) lines.push("_No local files matched._");
          else
            for (const f of data.localFiles) {
              lines.push(
                `- ${escapeMD(f.name)} ‚Äî ${escapeMD(f.type || "file")} ‚Äî ${
                  f.size
                } bytes ‚Äî ${escapeMD(f.path)}`
              );
            }
          lines.push("");
          return lines.join("\n");
        }

        /**
         * Escapes Markdown special characters
         * @param {string} s - String to escape
         * @returns {string} Markdown-safe string
         */
        function escapeMD(s) {
          return String(s).replace(/([\\`*_{}\[\]()#+\-.!])/g, "\\$1");
        }

        /**
         * Builds a restore manifest text file for a conversation
         * Includes folder structure suggestion and file listings
         * @param {Object} conv - Conversation object
         * @returns {string} Text manifest content
         */
        function buildRestoreManifest(conv) {
          const data = buildExportJSON(conv);
          const title = safeName(conv.title);
          const lines = [];

          lines.push(`ChatGPT Backup Export Viewer ‚Äî Restore Manifest`);
          lines.push(`Conversation ID: ${conv.id}`);
          lines.push(`Title: ${conv.title}`);
          lines.push(`Date: ${data.date ? formatDate(data.date) : ""}`);
          lines.push("");
          lines.push("üìÅ Suggested Folder Structure:");
          lines.push("ChatGPT_Archive/");
          lines.push("‚îú‚îÄ‚îÄ Conversations/");
          lines.push(`‚îÇ   ‚îú‚îÄ‚îÄ ${title}/`);
          lines.push("‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ conversation.json");
          lines.push("‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ conversation.md");
          lines.push("‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ attachments/");
          lines.push("‚îú‚îÄ‚îÄ Attachments/");
          lines.push("‚îî‚îÄ‚îÄ Misc/");
          lines.push("");
          lines.push("üß© References from chat.html / JSON:");
          if (!data.attachments.length) lines.push("- (none)");
          else
            for (const a of data.attachments)
              lines.push(
                `- ${a.filename || "(unknown)"} | ${a.type || "file"} | ${
                  a.href
                }`
              );
          lines.push("");
          lines.push("üì¶ Local files (imported):");
          if (!data.localFiles.length) lines.push("- (none)");
          else
            for (const f of data.localFiles)
              lines.push(
                `- ${f.name} | ${f.type || "file"} | ${f.size} bytes | ${
                  f.path
                }`
              );
          lines.push("");
          lines.push(
            "Note: This manifest is a text reference only. It does not include binary data."
          );

          return lines.join("\n");
        }

        /**
         * Triggers a browser download of a text file
         * @param {string} name - Filename for download
         * @param {string} text - Content to download
         * @param {string} [mime="text/plain"] - MIME type
         */
        function downloadFile(name, text, mime = "text/plain") {
          const blob = new Blob([text], { type: mime });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = name;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }

        els.btnJSON.addEventListener("click", () => {
          if (!currentConv) {
            els.expInfo.textContent = "‚ö†Ô∏è No conversation selected.";
            return;
          }
          const data = buildExportJSON(currentConv);
          const json = JSON.stringify(data, null, 2);
          downloadFile(
            safeName(currentConv.title) + ".json",
            json,
            "application/json"
          );
          els.expInfo.textContent = "‚úÖ JSON export completed.";
        });

        els.btnMD.addEventListener("click", () => {
          if (!currentConv) {
            els.expInfo.textContent = "‚ö†Ô∏è No conversation selected.";
            return;
          }
          const md = buildExportMarkdown(currentConv);
          downloadFile(
            safeName(currentConv.title) + ".md",
            md,
            "text/markdown"
          );
          els.expInfo.textContent = "‚úÖ Markdown export completed.";
        });

        els.btnManifest.addEventListener("click", () => {
          if (!currentConv) {
            els.expInfo.textContent = "‚ö†Ô∏è No conversation selected.";
            return;
          }
          const txt = buildRestoreManifest(currentConv);
          downloadFile(
            safeName(currentConv.title) + "_manifest.txt",
            txt,
            "text/plain"
          );
          els.expInfo.textContent = "‚úÖ Restore Manifest generated.";
        });

        // Init
        applyFilters();
      })();
    </script>
  </body>
</html>
